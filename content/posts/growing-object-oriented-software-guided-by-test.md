---
title: "Growing Object Oriented Software Guided by Test"
date: 2020-07-31T20:13:47+09:00
draft: true
tags:
  - テスト駆動開発
---

# 本のメタデータ

## タイトル

実践テスト駆動開発

## amazon URL

https://www.amazon.co.jp/dp/product/4798124583/ref=nosim?tag=inunekotokage-22

## 著者

- Steve Freeman (著)
- Nat Pryce (著)
- 和智 右桂 (翻訳)
- 高木 正弘 (翻訳)

## 気になった箇所

### 第 1 章 テスト駆動開発のポイントとは？

```
システムを確実に成長させ、常に起きる予期せぬ変化に対処していくためには、技術的な基盤がふたつ必要だということがわかった。
まずは、常にテストを実施してリグレッションエラーを検出する必要がある。
（中略）
次に必要なのは、コードをできる限りシンプルにしておくことだ。
```

（5p）

---

```
エンドツーエンドテストを実行することで、システムの外側の質がわかり、
エンドツーエンドテストを書くことでドメインについて私たち（チーム全体）がどれほど理解できているかについての知見が得られる。
しかし、エンドツーエンドテストではどのくらいコードがきちんと書かれているかはわからない。

一方、ユニットテストを書くことで、コードの質についてのフィードバックを数多く得ることができる。
さらに、ユニットテストを実行することで、どのクラスも壊れていないことがわかる。

しかし、繰り返しになるが、ユニットテストでは、システムが全体として機能することへの自信を十分には与えてはくれないのだ。
インテグレーションテストは、図1-3に示すように両者の間のどこかに位置づけられる。
```

（11p）

### 第 2 章 オブジェクトをテスト駆動開発する

```
私たちから見れば、ドメインモデルはこうしたコミュニケーションパターンの中に存在する。
なぜならコミュニケーションパターンこそが、オブジェクト間で生じ得る関係性という領域に意味を与えるからだ。
```

（17p）

---

```
クラス階層で表現できるのは、うまくいったとしてもせいぜいアプリケーションのある一側面だけにすぎない。
これは単に実装の詳細をオブジェクト間で共有する仕組みを提供しているだけだ。
```

（18p）

---

```
複数のオブジェクトが互いにメッセージを送りあっている。
そうしたメッセージはどんな内容だろう？
私達の経験によれば、呼び出し元のオブジェクトは、呼び出し先のオブジェクトが演じているロールの観点から、何をしてほしいかを記述しなければならない。
そして、どうやってそのようにするかは呼び出されたオブジェクトに任せるのだ。
これは一般的に「命じよ、訊ねるな（Tell, Don't Ask）」というフレーズで知られるスタイルであり、もっと形式ばった言い回しではデメテルの掟と呼ばれる。
```

（18p）

---

```
前傾のサンプルでいえば、短い方のコードは何のためかを明確に記述しており、列車事故のコードとは異なり、単にどのように実装しているかを記述するだけではなくなっているのだ。
```

（20p）

---

```
私たちは、オブジェクトに対する問い合わせをむやみに行わないようにしている（一方、値に対してはどんどん問い合わせをする）。
```

（21p）

---

```
モックオブジェクトを使うことで、起点となるイベントに対して、テスト対象のオブジェクトがどのように隣接モックとコミュニケーションするかについて、自分たちが期待する内容を定義できるのだ。
こうした定義のことをエクスペクテーションと呼ぶ。
```

（21p）

---

```
しかし実際には、ユニットテストを書いている時点では、こうした強調して動作するオブジェクトは存在しなくても構わない。
テストを使うことで、自分たちのオブジェクトが必要とする補助的なロールを明らかにすることができるのだ。
こうしたロールはJavaのインターフェイスとして定義され、実際に自走されるのはシステムの残りの部分を開発するときだ。
私たちはこれを、インターフェイスの発見と呼んでいる。
具体例としては、第12章でActionEventListenerを抽出していく。
```

（22p）

### 第 3 章 ツールの紹介

```
jMock APIの中核にある考え方は、モッカリーとモックオブジェクト、それからエクスペクテーションである。
モッカリーはテスト対象オブジェクトのコンテキスト、つまり隣接オブジェクトを表現している。
モックオブジェクトは、テストが実行されている間、テスト対象オブジェクトが呼び出す実際の隣接オブジェクトの代役となる。
そしてエクスペクテーションは、テスト対象オブジェクトがテストの間に隣接オブジェクトをどう呼び出すかを記述するのだ。
```

（30p）

### 第 4 章 テスト駆動のサイクルに火を入れる

```
このことで得られる大きな恩恵は、自分たちの学んだことに応じた変更が可能になるということだ。
すべてをテストファーストで書くということは、徹底したリグレッションテストが一式揃うということになる。
もちろん、完璧なテストなどというものは存在しないが、実際には、しっかりとしたテストスイートがあれば、大規模な変更も安全にできることがわかっている。
```

（40p）

### 第 5 章 テスト駆動のサイクルを保つ

```
まずはテストを失敗させて、診断メッセージを確認するのだ。
もしテストが予期せぬやり方で失敗した場合には、何かを誤解したか、コードが不十分だったかのどちらかだ。
その場合まずはそれを修正する。「正しく」失敗したら、診断メッセージを見て原因がわかることを確認する。
失敗理由の説明がわかりにくければ、数週間後にコードが壊れたときに誰かが（もしかしたら自分が）苦労することになる。
```

（46p）

---

```
エラーメッセージを確認せよと主張するのには、いくつかの理由がある。
第一に、取り組んでいるコードに対する私達の想定を確認できる。その想定が間違っていることも時々あるのだ。
第二に、もうすこし細かい話として、自分たちの意図を表現することを強調すること（情熱を傾けること、と言ってもよいかもしれない）は、
信頼でき保守しやすいシステムを開発する上で欠かせないことだと分かっている。
こうしたシステムには、テストや失敗メッセージも含まれるのだ。
手間を掛けて役に立つ診断メッセージが出力されるようにすることで、そのテストが何をすべきか、さらにそこから、そのコードが何をすべきかが明らかになる。
```

（47p）

---

```
新しいドメインモデルのユニットテストから始め、それをアプリケーション内の残りの部分に紐付けるという発想は魅力的だ。
そのほうが最初は簡単に思える。ドメインモデルを何かに組み入れる必要がなければ、非常に早く作業が進むように感じられる。
しかし、このやり方ではあとになって統合の問題に苦しめられることになるだろう。
あるいは、不要であったり、間違っていたりする機能を構築してしまって、時間を無駄にすることになるかもしれない。
作業時に適切なフィードバックを受け取ることができないからだ。
```

（47p）

---

```
これに関するよくある過ちが、メソッドをテストするという考え方だ。
testBidAccepted()という名前のついたテストは、何をしているかはわかるが、何のためにテストしているかが分からない。
むしろ、テスト対象のオブジェクトが提供すべきフィーチャに集中した方がよい。
それぞれのフィーチャでオブジェクトは複数の隣接オブジェクトとコラボレーションする必要があり、メソッドも複数呼び出されるからだ。
知りたいのは、目的を達成するためにクラスをどう使えばよいかということだ。
コード内のすべてのパスを実行する方法ではない。
```

（48p）

---

```
テストをするのが難しいフィーチャを見つけたときには、それをどうテストするかを自問するだけでなく、なぜテストするのが難しいのかも問わなければならないのだ。
```

（49p）

---

```
私たちの経験によれば、コードをテストするのが難しい場合、設計を改善する必要のあることがほとんどだ。
```

（49p）

---

```
図5-3が示すように次の失敗するテストを書くのが難しければ、プロダクションコードの設計を見直し、先に進む前にリファクタリングをするのである。
これは、私たちの格言である「予期せぬ変更を予期せよ」によって、開発がどう導かれるかを示す例である。
```

（49p）

---

```
モックオブジェクトを使って外部の依存関係を断ち切るようなユニットテストは、どのくらいやるべきだろう？
そして、インテグレーションテストはどのくらいやるべきだろう？
こうした問題に対して答えがひとつだけとは思わない。
チームや環境といったコンテキストに大きく依存しているからだ。
```

（50p）

---

```
TDDの持つテストの側面（これはTDDの大部分を占める）が与えてくれる最高のものは、コードを壊さずに変更できるという自信だ。
恐れると先に進めなくなる。
このときのコツは、自信を確実に裏付けることである。
```

（50p）

---

```
そして私たちは、TDDが自分たちにとって機能しているか、あらゆる欠点を見定めているか、テスト戦略に適しているか、といったことを定期的にふりかえるのだ。
```

（50p）

### 第 6 章 オブジェクト指向スタイル

```
関心事を分離する
システムの振る舞いを変更しなければいけないときには、変更するコードの量はできる限り少なくしたい。
関連する変更がコード内ですべて一か所にまとまっていれば、作業を終わらせるためにシステムの中を探し回らなくてもよくなる。
システム内の特定箇所をいつ変更しなければならなくなるかを予想することはできないから、同じ理由で変更することになるであろうコードはまとめておくのだ。
```

（52p）

---

```
抽象度を高める
人間が複雑さに対処するための唯一の方法は、より高い抽象度で作業することによってシンプルにとらえるようにすることだけだ。
プログラムを作るときに、単に変数やフロー構造を操作するだけでなく、役に立つ機能のコンポーネントを組み合わせるようにすれば、もっと多くのことができる。
```

（52p）

---

```
これらふたつのフォースを一貫して適用すれば、アプリケーションの構造はコーバーンが「ポートとアダプタ」アーキテクチャと呼んだものに近づいていく。
このアーキテクチャではビジネスドメインのコードが、データベースやユーザーインターフェイスといった技術基盤との依存関係から切り離される。
技術的な概念がアプリケーションモデルに流出するのは避けたい。
そこでインターフェイスを書いて、外部の世界との関係をアプリケーションの用語にしたがって説明するのだ（コーバーンの言うポート）。
その上で、アプリケーションの中核と、各技術ドメインとの間に置かれるブリッジを書く（コーバーンの言うアダプタ）。
これはエリック・エヴァンスが「腐敗防止層」と呼ぶものに似ている。
```

（52p）

---

```
この例に示すゲッターメソッドは、どれも構造的な詳細をさらけ出している。
このコードが示しているのはマスタに対するカスタマイズを可能にする方法だが、これを変更しようと思えば、内部の関係をすべて変更しなければならなくなるだろう。
```

（55p）

---

```
私たちの経験によれば、オブジェクトが何をしているかは、接続詞（"and" や "or"）を使わずに説明できなければならないのだ。
「Aをして、Bをする」というように、説明に節を追加しようとしていることに気づいたとしたら、おそらくそのオブジェクトは協力しあう複数のオブジェクトに分解するべきだろう。
たいていの場合、各節に対してひとつのオブジェクトが該当する。
```

（56p）

---

```
依存
あるオブジェクトが自身の責務を果たすために、ピアに対して要求するサービス。
そのオブジェクトはこれらのサービスがなければ機能できない。
このようなオブジェクトは、依存するサービスがなければ生成できないようにしなければならない。
```

（56p）

---

```
通知
特定のオブジェクトが活動する際に、そのオブジェクトの最新情報を取得し続ける必要のあるピア。
そのオブジェクトは状態が変更された場合や重要なアクションを行った場合に必ず、関心を持ったピアに対してそのことを通知する。
通知とは「伝えて忘れる」ということだ。
つまり、どのピアがリッスンしているかということについて、そのオブジェクトは知らないし関心も持たない。
通知が役に立つのは、オブジェクトを互いに疎結合にするからだ。
```

（56p）

---

```
調整
システムにおけるより幅広い要求に応じてオブジェクトの振る舞いを調整するピア。
```

（56p）

---

```
コンポジットオブジェクトのAPIは、その構成要素よりも複雑になってはならない。
```

（58p）

---

```
オブジェクトがコンテキストから独立しているほど、システムを変更するのが容易になる。
つまり各オブジェクトに、それを実行するシステムに関する知識が組み込まれていなければよいのだ。
```

（59p）

### 第 7 章 オブジェクト指向設計を実現する

```
TDDには、こうしたスコープ定義を実現する上で役立つ側面が三つある。
第一に、テストから先に書き始めるということは、まず何を実現したいか記述し、その後でどうやって実現するかを考えるということだ。
（中略）
第二に、ユニットテストをわかりやすく（したがって保守しやすく）保つためには、スコープを限定しなければならない。
ユニットテストの中には、数十行にわたっているせいで、テストのポイントがセットアップのどこかに埋もれてしまっているものもある。
こうしたテストからわかるのは、テスト対象のコンポーネントがあまりに大きいので、より小さいコンポーネントに分解する必要があるということだ。
（中略）
第三に、あるオブジェクトをユニットテスト用に構築するには、依存ピアを渡さなければならない。
つまり、何に依存しているかを知っている必要があるのだ。
こうすることでコンテキストの独立性が高まる。
```

（61p）

---

```
確かに、クラス構造はうまく設計したい。
しかし、オブジェクト間のコミュニケーションパターンの方が重要だと考えるのである。
Javaのような言語では、インターフェイスを使ってオブジェクト間のやり取りに使えるメッセージを定義できる。
しかし同時に、コミュニケーションのパターンも定義する必要がある。
これは言わば、コミュニケーションプロトコルだ。
```

（62p）

---

```
私たちがモックオブジェクトと共にTDDを用いるのは、こうしたコミュニケーションプロトコルを明示するためだ。
TDDやモックは、コミュニケーションプロトコルを開発時に発見するためのツールであると同時に、コードを後で見たときの説明にもなる。
```

（62p）

---

```
コードの新しい領域を書き始めるときには、一時的に設計の判断を棚上げし、あまり構造を押し付けようとしないでコードをただ書く。
こうすることで、その領域に対してなんらかの経験を積むことができるし、開発時に利用する外部APIを自分たちが理解しているかどうかを試すことができる.
すこし経つと、コードがあまりに複雑で理解できなくなりつつあることに気づき、きれいにしたいと思うようになる。
機能に関する凝集したユニットを抜き出して、協力しあうもっと小さいオブジェクトにする。
すると、独立してユニットテストを行えるようになる。
新しいオブジェクトを切り出すことで、抜き出したコードの依存関係に注意を払わざるを得なくなる。
```

（64p）

---

```
新しい振る舞いに対しては、あたかもそのサービスがすでに存在しているかのようにしてテストを書く。
その際、モックオブジェクトを使って、テスト対象オブジェクトと新しいコラボレータとの関係を記述するのだ。
```

（65p）

---

```
これについて、私たちは「オンデマンド」の設計と考えている。
インターフェイスと実装をクライアントの必要性から「プルして」具現化するのだ。
あるクラスが提供すべきと考えるフィーチャを「プッシュする」のではない。
```

（66p）

---

```
BookingImplのような名前は重複である。
これでは、後に続く implements Booking とまったく同じことを言っているだけで、まさに「きな臭いコード」である。
どこであれ、コードの中にこうしたあからさまな重複があるのは好ましくない。
したがってリファクタリングして取り除かなければならない。
```

（68p）

---

```
プロトコルに対応するインターフェイスができれば、今度は似ているものと異なるものに注意を向け始めることができる。
こういうとき私たちは、コードベースの大きさが妥当であれば、似通っているように見えるインターフェイスから探し始めることが多い。
インターフェイスが似通っているということはつまり、そうしたインターフェイスが単一の概念を表現していて、マージされるべきなのかを調べなければならないということだ。
共通のロールを抽出することで、設計は一層順応力を増す。
より多くのコンポーネントが「プラグ互換」になるからだ。
それによって、より抽象度の高いレベルで作業できるようになる。
開発者にとっては副次的な利点もある。
すなわち、時間をかけて理解しなければならない概念の数が減るのだ。
```

（68p）

---

```
私たちの最終的な目的は、より少ないコードでより多くを実現することだ。
私たちが切望しているのは、制御フローとデータ操作という観点からプログラミングすることを卒業し、より小さいプログラムを組み合わせてプログラムを作るということだ。
そういうプログラムでは、オブジェクトが振る舞いの最小単位を構成する。
```

（71p）

### 第 9 章 オークションスナイパーを作動させる

```
インクリメンタルな開発においてもっとも重要なテクニックは、どうやって機能をスライスし、一度にすこしずつ構築できるようにするか、ということだ。
スライスひとつひとつは、いつ完成したかをチームがわかるように、意味を持ち、具体的でなければならない。
しかも、ひとつの概念に集中し、すぐに完成できるよう十分小さいものでなければならない。
自分たちの仕事を一貫した小さな塊に分割することで、開発のリスクも管理できるようになる。
自分たちの進捗に対する具体的なフィードバックを定期的に得られるので、ドメインや扱う技術についてより多くのことをチームが理解したときに、計画を調整することができる。
```

（83p）

### 第 10 章 動くスケルトン

```
テスト駆動開発における重要なスキルのひとつに、何をテストし、最終的にどうやってすべてを網羅するかという境界を設定するというものがある。
```

（92p）

### 第 11 章 最初のテストを通す

```
ただ、重要なのは、私達は常にコマンドをひとつ叩くことで、
アプリケーションのコンパイルからビルド、デプロイ、テストまでを安定して行うということ、
そしてそのコマンドは繰り返し実行するということだ。
自動ビルドとテストが動くようになってはじめて、私達はコーディングを始めるのである。
```

（100p）

### 第 12 章 入札を準備する

```
私たちはオブジェクト指向の信奉者なので、まずこれらのメッセージを型としてモデリングしてみる。
しかし、構造に意味を持たせることを正当化するような振る舞いがあるかどうかはっきりわからなかったので、その考えは撤回した。
まずは単純な解決策から始めて、そこから肉付けしていくことにする。
```

（122p）

---

```
だがまず最初にやったのは、荒削りな実装を書くことによって、
求められていることをどうすればコードで実現できるかを自分たちが理解していることを証明することだった。
リファクタリングを行うのはその後だ。
```

（126p）

### 第 13 章 スナイパーが入札する

```
createChat() メソッドを見ると、Chatオブジェクトを生成する上でMessageListenerが必要とされているようだが、実際にはそうではない。
本書の用語を使えば、MessageListenerは通知ピアだ。Chatオブジェクトを生成するときにはnullを渡しておき、後でMessageListenerを追加してもよい。
```

（133p）

---

```
自分たちの経験に基づき、私達はジェネリクス（山カッコで囲まれた型）のついた型を持ち回るのを控えるようにしている。
特にジェネリクスがコレクションに適用されているようなとき、私達はそれを重複の一形態と見なす。
こうしたコレクションは、型として抽出するべきドメインの概念が存在することの兆候なのだ。
```

（140p）

### 第 14 章 スナイパーがオークションで落札する

```
このようなケースでは、オブジェクトが状態に応じた振る舞いをしていることについてアサーションを行いたい。
しかし、状態がどのように実装されているかを暴露することでカプセル化を破壊することも好ましくない。
その代わりに、テストではスナイパーの通知イベントをリッスンすることができる。
```

（151p）

### 第 15 章 実際のユーザーインターフェイスに向けて

```
今度は同じことを「一位入札中」「落札失敗」「落札成功」に対してもやらなければならない。
だが、はっきり言って、それはあまりに間が抜けている。
他のイベントに対しても動くようにするためには、作業をあまりにたくさん繰り返さないといけない。
イベントをスナイパー内で生成し、複数のレイヤを通じて受け渡すといったことを繰り返すというのか。
設計がどこかおかしい。
```

（165p）

---

```
最初の段階でなぜわからなかったのだろう？
設計にもっと時間を割いていれば、今変更することにはならなかったのではないか？
そういうことも確かにある。
だが経験によれば、実際に実装してみるほどに設計を揺さぶるものは他にない。
それに常に正しく設計できる賢い人なんて、数えるほどしか知らない。
だからうまくやるためには、重要な領域のコードに初期の段階から取り組まなければならないし、そしてもっとよい方法が見つかった時には全員の考え方を変えられるようにしておかなければならない。
私たちが頼りにするのは、小さいステップで進むことを可能にするスキルであり、変更を行う場合に自分たちを守ってくれるテストである。
```

（166p）

---

```
次にswitch文を取り除く。
この構文はオブジェクト指向的はないし、ノイズも多く、不要なdefault句まで含んでいる。
このdefault句はコンパイルを通すためにあるだけだ。
switch文はすでに目的を果たした。
```

（173p）

---

```
設計をいつ変更するかを決めるには、トレードオフに対する優れた感覚が必要だ。
そのためには感受性が高く、技術的にも熟達していなければならない。
「ちょっと変えただけのコードをコピーして使おうとしている。これは馬鹿馬鹿しいし、時間のむだだ」なのか、「今はこれを修正すべきときではない。まだよくわかっていないのだ」なのか。
この方針について、再現可能でシンプルなテクニックは存在しない。
スキルと経験が必要なのだ。
だから、開発者は自分たちの活動について深く考えるよう習慣づけなければならない。
この後のコーディングのために自分たちの時間を投資するもっとよい方法は何か、と。
その結果、今までとまったく同じようにやることになるかもしれない。
しかし、少なくともそれについて考えてはいるのだ。
```

（179p）

### 第 16 章 複数の商品をスナイプする

```
少し議論した後で、MainWindowのやるべき仕事はUIコンポーネントとその相互作用を管理することだと思い出した。
だから、「接続」や「チャット」といった概念まで管理してはいけない。
ユーザとの相互作用にユーザーインターフェイス外のオークションが暗に含まれているなら、MainWindowはコラボレートするオブジェクトに処理を委譲しなければならない。
```

（193p）

### 第 17 章 Main クラスを分解する

```
これを動くようにするには、スナイパーのリスナを「依存ピア」から「通知ピア」に変更し、コンストラクタを呼び出した後でリスナに追加できるようにしたい。
```

（207p）

### 第 18 章 詳細を詰める

```
このダイナミクスは、設計を固定するアプローチともコードを書いてそれを固定するアプローチとも大きく異なる。
設計を固定するアプローチでは、開発の構造が作業を始める前に承認されなければならない。
一方コードを書いて固定するアプローチでは、最初のうちはシステムがうまく動くかもしれないが、システムに求められる役割が変わっていくときに十分対応することができない。
```

（213p）

---

```
開発も終盤になってから、私たちがまたしても重大な変更をユーザインターフェイスに加えているように見えるかもしれない。
こうなることを予見できなかったのだろうか？
これはアジャイルユーザーエクスペリエンスコミュニティで活発に議論されている話題であり、いつものように答えは「場合によるけれど、思っているよりは柔軟だよ」だ。
```

（221p）

---

```
ここで言いたいのは、まだ存在が証明されていない要望に対してもっと投機的に設計すべきだったということではない。
むしろ、ドメインを明確に表現できないという問題が生じた時に、他にも選択肢があるとわかることが多いのである。
```

（222p）

### 第 19 章 エラー処理

```
この技術を習得する上では、要件をインクリメンタルなスライスに分割する方法を学ぶ必要がある。
常に何かを動くようにしておき、追加するフィーチャは常にひとつだけにするのだ。
このプロセスは厳しいと感じられるかもしれない。
常に作業が続いていくからだ。
このプロセスがうまくいくようにするためには、コードをインクリメンタルに変更するにはどうすればよいかを理解しなければならない。
また、さらに重要なのはコードの構造をきれいに保って、必要に応じてどこへでも向かっていけるようにすることだ（しかも、どこに向かうかはまだわからない）。
だからこそ、テスト駆動開発のサイクルにおいてはリファクタリングが決定的に重要なのだ。
フィーチャの実装だけをやってリファクタリングが追いついていないと、必ず困ったことになる。
```

（234p）

---

```
私たちにはヘルパーメソッドを書いて、少量のコードをまとめるという習慣がある。（中略）ヘルパーメソッドを作ることで、構造に意味のある名前が与えられる。
そうでもしなければ、構造の意味は明らかにならないのだ。
```

（235p）

### 第 20 章 テストの声を聴く

```
自分たちのコードに何らかの機能を追加しようとして、そのテストを書くのが難しいと気づくことがある。
経験上、これはたいてい設計に改善の余地があることを意味する。
クラスが環境と密に結合しすぎているのかもしれないし、クラスの責務が明確になっていないのかもしれない。
テストが書きづらいと感じたら、私たちはまずコードを改善できないかどうかを考える。
```

（239p）

---

```
テストを使って設計を進めるというのがコツである（テスト駆動開発と呼ばれるのもそのためだ）。
TDDは、コードをテストして、機能や性能などの外部から見える質を検証するものだ。
TDDはまた、コードの内側の質に関するフィードバックを得るものでもある。
内側の質とは、クラス間の結合度やまとまり、明示された（あるいは隠れた）依存性、（コードの保守性を保つための）効果的な情報隠蔽などのことである。
```

（239p）

---

```
暗黙のコンポーネントを抽出するときには、まず次のふたつの条件を探す。
クラス内で常に同時に使われている引数はないか、そして生存期間の同じ引数はないか。
条件を満たすものが見つかったら、より難しいタスクにとりかかる。
その概念をうまく説明する名前を考えるのだ。
```

（250p）

---

```
肥大したコンストラクタの三番目の症例は、引数の中に「依存ピア」ではないものが存在するというものだ。
「依存ピア」とは、「オブジェクトピアのステレオタイプ」（56ページ）で定義したステレオタイプのひとつだ。
そこでも書いたように、私たちは「依存」だけをコンストラクタで渡すように主張している。
「通知ピア」や「調整ピア」については、デフォルトを設定しておいて後から変更できるようにしておけばよい。
```

（252p）

---

```
意図を明確にするためには、スタブとエクスペクテーションやアサーションをきちんと区別するとよい。
スタブは実際の挙動をシミュレートしてテストの実行を支援するためのもの、そしてエクスペクテーションやアサーションはあるオブジェクトが隣接オブジェクトとどのようなやり取りをするのかを確かめるためのものだ。
```

（254p）

---

```
これまでに見てきたきな臭いテストの中には、たとえば「裏技」を使わないとモックを作成できない場合のように、コンポーネント間で知識が漏れ出しているせいでそうなっているものがある。
```

（256p）

---

```
「命じよ、訊ねるな」の方針を常に適用することを心がけると、値をスタックに積むのではなく、振る舞いを（コールバック形式で）システムに渡すようなコーディングスタイルにつながる。
```

（256p）

---

```
私が最近参加していたプロジェクトではjMockをヘビーに使い込んでいた。
振り返ってみると、そこで私が目にしたのはこのようなものだった。

1. ユニットテストが解読不能（何をやっているのかがわからない）になることがある。
2. テストクラスのコードが500行にも達することがある。さらに、そのクラスは別の抽象クラスを継承したものだったが、抽象クラス側のコードも500行に達している。
3. リファクタリングすると、テストコードに大量の変更が発生することがある。

ユニットテストが1000行にもなるなんて、あり得ないことだ！
```

（257p）

### 第 21 章 テストの可読性

```
TDDを続けていくためには、テストが単にコードの振る舞いを検証するだけでは不十分だ。
それだけではなく、テストで振る舞いを明確に表現しておかなければならない。
つまり、テストが読みやすくなければならないのだ。
```

（259p）

---

```
テストコードは、プロダクションコードが何をするのかを説明するものでなければならない。
```

（259p）

---

```
テストコードは依存関係の末端にあるので、テスト対象コードの意図を表現する方が、他のオブジェクトの網の目に組み込むことよりも重要となる。
```

（259p）

---

```
私たちがテストをきれいにしたり新たにテストを書いたりするときに、可読性を損なう問題として気をつけているのは以下の点だ。
・テスト名が、ここのテストケースのポイントや他のテストケースとの違いについてきちんと説明できていない。
・ひとつのテストケースが複数のフィーチャを実行しているように見える。
・さまざまな仕組みでテストしているため、ざっと眺めただけではテストの意図をつかみにくい。
・テストのセットアップや例外処理のためのコードが大量にあり、本質的なロジックが埋もれてしまっている。
・テストの中でリテラル値（「マジックナンバー」）が使われており、その値の何が重要（仮に重要であるとして）なのかがはっきりしない。
```

（260p）

- アンチパターン一覧

---

```
このような命名は、単に対象のクラスを見ればわかる情報を重複させているにすぎない。
「同じことを繰り返すな（Don't Repeat Yourself）」原則に反しているのだ。
```

（261p）

---

```
私たちは、クリス・スチーブンソンが考案したTestDoxの規約を使っている。
この規約では、テスト対象のクラスを暗黙の主語として、テスト名を一つの文として読めるようにする。
```

（261p）

---

```
この規約のポイントは、開発者にそのオブジェクトが「何者なのか」ではなく「何をするのか」という観点で考えさせるようにするということだ。
```

(261p）

- この `「何をするのか」` というのが振る舞いのことなのだろう

---

```
TDDを実践している人たちの中には、ひとつのテストに含めるエクスペクテーションやアサーションはひとつだけにするべきだと言う人もいる。
これは、TDDを学ぶときの練習用ルールとしては有用で、開発者の考え得ることをすべてアサートしてしまうことを避けられる。
しかし、実践的ではない。
ひとつのテストではひとつの凝集したフィーチャをテストするルールにした方がよい。
この場合、アサーションの数が少し増えても構わない。
ひとつのテストで異なるフィーチャのアサーションを行っているように見えたら、そのテストは分割したほうがよいだろう。
```

（264p）

- `考え得ることをすべてアサートしてしまう` というのはやりたくなりがちなことである

---

```
実装の詳細がテストメソッドに含まれれば含まれるほど、コードを読むときに何が重要なのかを読み取りにくくなる。
```

（264p）

---

```
テストの構造をこのように切り出す際に唯一気をつける点は、本章の冒頭に書いたとおり、テストをあまり抽象化しすぎないことだ。
さもないと、そのテストが何をしているのかを読み取れなくなってしまう。
私たちがもっとも重視しているのは、テストできちんと対象コードの動きを説明することだ。
```

（265p）

---

```
テストに書くアサーションやエクスペクテーションは、対象コードがどのように振る舞うのかを正確に伝えなければならない。
アサーションを細かくしすぎているテストをよく見かけるが、そうするとテストが読みにくく、変更にもろいものとなってしまう。
```

（267p）

## 考えたこと

- 戻り値の無いメソッドをテストすべきか・どうテストするのが適切か疑問だった
  - オブジェクト同士がメッセージを送り合うという点に着目すると、他のオブジェクトにメッセージを送ることがそのメソッドの責務になる
    - これをテストするのが適切ではないかという仮説を抱いた
