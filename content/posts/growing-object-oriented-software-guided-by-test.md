---
title: "Growing Object Oriented Software Guided by Test"
date: 2020-07-31T20:13:47+09:00
draft: true
tags:
  - テスト駆動開発
---

# 本のメタデータ

## タイトル

実践テスト駆動開発

## amazon URL

https://www.amazon.co.jp/dp/product/4798124583/ref=nosim?tag=inunekotokage-22

## 著者

- Steve Freeman (著)
- Nat Pryce (著)
- 和智 右桂 (翻訳)
- 高木 正弘 (翻訳)

## 気になった箇所

### 第 1 章 テスト駆動開発のポイントとは？

```
システムを確実に成長させ、常に起きる予期せぬ変化に対処していくためには、技術的な基盤がふたつ必要だということがわかった。まずは、常にテストを実施してリグレッションエラーを検出する必要がある。（中略）次に必要なのは、コードをできる限りシンプルにしておくことだ。
```

（5p）

---

```
エンドツーエンドテストを実行することで、システムの外側の質がわかり、
エンドツーエンドテストを書くことでドメインについて私たち（チーム全体）がどれほど理解できているかについての知見が得られる。
しかし、エンドツーエンドテストではどのくらいコードがきちんと書かれているかはわからない。

一方、ユニットテストを書くことで、コードの質についてのフィードバックを数多く得ることができる。
さらに、ユニットテストを実行することで、どのクラスも壊れていないことがわかる。

しかし、繰り返しになるが、ユニットテストでは、システムが全体として機能することへの自信を十分には与えてはくれないのだ。
インテグレーションテストは、図1-3に示すように両者の間のどこかに位置づけられる。
```

（11p）

### 第 2 章 オブジェクトをテスト駆動開発する

```
私たちから見れば、ドメインモデルはこうしたコミュニケーションパターンの中に存在する。
なぜならコミュニケーションパターンこそが、オブジェクト間で生じ得る関係性という領域に意味を与えるからだ。
```

（17p）

---

```
クラス階層で表現できるのは、うまくいったとしてもせいぜいアプリケーションのある一側面だけにすぎない。
これは単に実装の詳細をオブジェクト間で共有する仕組みを提供しているだけだ。
```

（18p）

---

```
複数のオブジェクトが互いにメッセージを送りあっている。
そうしたメッセージはどんな内容だろう？
私達の経験によれば、呼び出し元のオブジェクトは、呼び出し先のオブジェクトが演じているロールの観点から、何をしてほしいかを記述しなければならない。
そして、どうやってそのようにするかは呼び出されたオブジェクトに任せるのだ。
これは一般的に「命じよ、訊ねるな（Tell, Don't Ask）」というフレーズで知られるスタイルであり、もっと形式ばった言い回しではデメテルの掟と呼ばれる。
```

（18p）

---

```
前傾のサンプルでいえば、短い方のコードは何のためかを明確に記述しており、列車事故のコードとは異なり、単にどのように実装しているかを記述するだけではなくなっているのだ。
```

（20p）

---

```
私たちは、オブジェクトに対する問い合わせをむやみに行わないようにしている（一方、値に対してはどんどん問い合わせをする）。
```

（21p）

---

```
モックオブジェクトを使うことで、起点となるイベントに対して、テスト対象のオブジェクトがどのように隣接モックとコミュニケーションするかについて、自分たちが期待する内容を定義できるのだ。
こうした定義のことをエクスペクテーションと呼ぶ。
```

（21p）

---

```
しかし実際には、ユニットテストを書いている時点では、こうした強調して動作するオブジェクトは存在しなくても構わない。
テストを使うことで、自分たちのオブジェクトが必要とする補助的なロールを明らかにすることができるのだ。
こうしたロールはJavaのインターフェイスとして定義され、実際に自走されるのはシステムの残りの部分を開発するときだ。
私たちはこれを、インターフェイスの発見と呼んでいる。
具体例としては、第12章でActionEventListenerを抽出していく。
```

（22p）

### 第 4 章 テスト駆動のサイクルに火を入れる

```
このことで得られる大きな恩恵は、自分たちの学んだことに応じた変更が可能になるということだ。
すべてをテストファーストで書くということは、徹底したリグレッションテストが一式揃うということになる。
もちろん、完璧なテストなどというものは存在しないが、実際には、しっかりとしたテストスイートがあれば、大規模な変更も安全にできることがわかっている。
```

（40p）

### 第 5 章 テスト駆動のサイクルを保つ

```
まずはテストを失敗させて、診断メッセージを確認するのだ。
もしテストが予期せぬやり方で失敗した場合には、何かを誤解したか、コードが不十分だったかのどちらかだ。
その場合まずはそれを修正する。「正しく」失敗したら、診断メッセージを見て原因がわかることを確認する。
失敗理由の説明がわかりにくければ、数週間後にコードが壊れたときに誰かが（もしかしたら自分が）苦労することになる。
```

（46p）

---

```
エラーメッセージを確認せよと主張するのには、いくつかの理由がある。
第一に、取り組んでいるコードに対する私達の想定を確認できる。その想定が間違っていることも時々あるのだ。
第二に、もうすこし細かい話として、自分たちの意図を表現することを強調すること（情熱を傾けること、と言ってもよいかもしれない）は、
信頼でき保守しやすいシステムを開発する上で欠かせないことだと分かっている。
こうしたシステムには、テストや失敗メッセージも含まれるのだ。
手間を掛けて役に立つ診断メッセージが出力されるようにすることで、そのテストが何をすべきか、さらにそこから、そのコードが何をすべきかが明らかになる。
```

（47p）

---

```
新しいドメインモデルのユニットテストから始め、それをアプリケーション内の残りの部分に紐付けるという発想は魅力的だ。
そのほうが最初は簡単に思える。ドメインモデルを何かに組み入れる必要がなければ、非常に早く作業が進むように感じられる。
しかし、このやり方ではあとになって統合の問題に苦しめられることになるだろう。
あるいは、不要であったり、間違っていたりする機能を構築してしまって、時間を無駄にすることになるかもしれない。
作業時に適切なフィードバックを受け取ることができないからだ。
```

（47p）

---

```
これに関するよくある過ちが、メソッドをテストするという考え方だ。
testBidAccepted()という名前のついたテストは、何をしているかはわかるが、何のためにテストしているかが分からない。
むしろ、テスト対象のオブジェクトが提供すべきフィーチャに集中した方がよい。
それぞれのフィーチャでオブジェクトは複数の隣接オブジェクトとコラボレーションする必要があり、メソッドも複数呼び出されるからだ。
知りたいのは、目的を達成するためにクラスをどう使えばよいかということだ。
コード内のすべてのパスを実行する方法ではない。
```

（48p）

---

```
テストをするのが難しいフィーチャを見つけたときには、それをどうテストするかを自問するだけでなく、なぜテストするのが難しいのかも問わなければならないのだ。
```

（49p）

---

```
私たちの経験によれば、コードをテストするのが難しい場合、設計を改善する必要のあることがほとんどだ。
```

（49p）

---

```
図5-3が示すように次の失敗するテストを書くのが難しければ、プロダクションコードの設計を見直し、先に進む前にリファクタリングをするのである。
これは、私たちの格言である「予期せぬ変更を予期せよ」によって、開発がどう導かれるかを示す例である。
```

（49p）

---

```
モックオブジェクトを使って外部の依存関係を断ち切るようなユニットテストは、どのくらいやるべきだろう？
そして、インテグレーションテストはどのくらいやるべきだろう？
こうした問題に対して答えがひとつだけとは思わない。
チームや環境といったコンテキストに大きく依存しているからだ。
```

（50p）

---

```
TDDの持つテストの側面（これはTDDの大部分を占める）が与えてくれる最高のものは、コードを壊さずに変更できるという自信だ。
恐れると先に進めなくなる。
このときのコツは、自信を確実に裏付けることである。
```

（50p）

---

```
そして私たちは、TDDが自分たちにとって機能しているか、あらゆる欠点を見定めているか、テスト戦略に適しているか、といったことを定期的にふりかえるのだ。
```

（50p）

### 第 6 章 オブジェクト指向スタイル

```
この例に示すゲッターメソッドは、どれも構造的な詳細をさらけ出している。
このコードが示しているのはマスタに対するカスタマイズを可能にする方法だが、これを変更しようと思えば、内部の関係をすべて変更しなければならなくなるだろう。
```

（55p）

---

```
私たちの経験によれば、オブジェクトが何をしているかは、接続詞（"and" や "or"）を使わずに説明できなければならないのだ。
「Aをして、Bをする」というように、説明に節を追加しようとしていることに気づいたとしたら、おそらくそのオブジェクトは協力しあう複数のオブジェクトに分解するべきだろう。
たいていの場合、各節に対してひとつのオブジェクトが該当する。
```

（56p）

---

```
コンポジットオブジェクトのAPIは、その構成要素よりも複雑になってはならない。
```

（58p）

---

```
オブジェクトがコンテキストから独立しているほど、システムを変更するのが容易になる。
つまり各オブジェクトに、それを実行するシステムに関する知識が組み込まれていなければよいのだ。
```

（59p）

### 第 7 章 オブジェクト指向設計を実現する

```
TDDには、こうしたスコープ定義を実現する上で役立つ側面が三つある。
第一に、テストから先に書き始めるということは、まず何を実現したいか記述し、その後でどうやって実現するかを考えるということだ。
（中略）
第二に、ユニットテストをわかりやすく（したがって保守しやすく）保つためには、スコープを限定しなければならない。
ユニットテストの中には、数十行にわたっているせいで、テストのポイントがセットアップのどこかに埋もれてしまっているものもある。
こうしたテストからわかるのは、テスト対象のコンポーネントがあまりに大きいので、より小さいコンポーネントに分解する必要があるということだ。
（中略）
第三に、あるオブジェクトをユニットテスト用に構築するには、依存ピアを渡さなければならない。
つまり、何に依存しているかを知っている必要があるのだ。
こうすることでコンテキストの独立性が高まる。
```

（61p）

---

```
確かに、クラス構造はうまく設計したい。
しかし、オブジェクト間のコミュニケーションパターンの方が重要だと考えるのである。
Javaのような言語では、インターフェイスを使ってオブジェクト間のやり取りに使えるメッセージを定義できる。
しかし同時に、コミュニケーションのパターンも定義する必要がある。
これは言わば、コミュニケーションプロトコルだ。
```

（62p）

---

```
私たちがモックオブジェクトと共にTDDを用いるのは、こうしたコミュニケーションプロトコルを明示するためだ。
TDDやモックは、コミュニケーションプロトコルを開発時に発見するためのツールであると同時に、コードを後で見たときの説明にもなる。
```

（62p）

---

```
コードの新しい領域を書き始めるときには、一時的に設計の判断を棚上げし、あまり構造を押し付けようとしないでコードをただ書く。
こうすることで、その領域に対してなんらかの経験を積むことができるし、開発時に利用する外部APIを自分たちが理解しているかどうかを試すことができる.
すこし経つと、コードがあまりに複雑で理解できなくなりつつあることに気づき、きれいにしたいと思うようになる。
機能に関する凝集したユニットを抜き出して、協力しあうもっと小さいオブジェクトにする。
すると、独立してユニットテストを行えるようになる。
新しいオブジェクトを切り出すことで、抜き出したコードの依存関係に注意を払わざるを得なくなる。
```

（64p）

---

```
新しい振る舞いに対しては、あたかもそのサービスがすでに存在しているかのようにしてテストを書く。
その際、モックオブジェクトを使って、テスト対象オブジェクトと新しいコラボレータとの関係を記述するのだ。
```

（65p）

---

```
これについて、私たちは「オンデマンド」の設計と考えている。
インターフェイスと実装をクライアントの必要性から「プルして」具現化するのだ。
あるクラスが提供すべきと考えるフィーチャを「プッシュする」のではない。
```

（66p）

---

```
BookingImplのような名前は重複である。
これでは、後に続く implements Booking とまったく同じことを言っているだけで、まさに「きな臭いコード」である。
どこであれ、コードの中にこうしたあからさまな重複があるのは好ましくない。
したがってリファクタリングして取り除かなければならない。
```

（68p）

---

```
プロトコルに対応するインターフェイスができれば、今度は似ているものと異なるものに注意を向け始めることができる。
こういうとき私たちは、コードベースの大きさが妥当であれば、似通っているように見えるインターフェイスから探し始めることが多い。
インターフェイスが似通っているということはつまり、そうしたインターフェイスが単一の概念を表現していて、マージされるべきなのかを調べなければならないということだ。
共通のロールを抽出することで、設計は一層順応力を増す。
より多くのコンポーネントが「プラグ互換」になるからだ。
それによって、より抽象度の高いレベルで作業できるようになる。
開発者にとっては副次的な利点もある。
すなわち、時間をかけて理解しなければならない概念の数が減るのだ。
```

（68p）

---

```
私たちの最終的な目的は、より少ないコードでより多くを実現することだ。
私たちが切望しているのは、制御フローとデータ操作という観点からプログラミングすることを卒業し、より小さいプログラムを組み合わせてプログラムを作るということだ。
そういうプログラムでは、オブジェクトが振る舞いの最小単位を構成する。
```

（71p）

### 第 9 章 オークションスナイパーを作動させる

```
インクリメンタルな開発においてもっとも重要なテクニックは、どうやって機能をスライスし、一度にすこしずつ構築できるようにするか、ということだ。
スライスひとつひとつは、いつ完成したかをチームがわかるように、意味を持ち、具体的でなければならない。
しかも、ひとつの概念に集中し、すぐに完成できるよう十分小さいものでなければならない。
自分たちの仕事を一貫した小さな塊に分割することで、開発のリスクも管理できるようになる。
自分たちの進捗に対する具体的なフィードバックを定期的に得られるので、ドメインや扱う技術についてより多くのことをチームが理解したときに、計画を調整することができる。
```

（83p）

### 第 10 章 動くスケルトン

```
テスト駆動開発における重要なスキルのひとつに、何をテストし、最終的にどうやってすべてを網羅するかという境界を設定するというものがある。
```

（92p）

### 第 11 章 最初のテストを通す

```
ただ、重要なのは、私達は常にコマンドをひとつ叩くことで、
アプリケーションのコンパイルからビルド、デプロイ、テストまでを安定して行うということ、
そしてそのコマンドは繰り返し実行するということだ。
自動ビルドとテストが動くようになってはじめて、私達はコーディングを始めるのである。
```

（100p）

### 第 19 章 エラー処理

```
私たちにはヘルパーメソッドを書いて、少量のコードをまとめるという習慣がある。（中略）ヘルパーメソッドを作ることで、構造に意味のある名前が与えられる。
そうでもしなければ、構造の意味は明らかにならないのだ。
```

（235p）

### 第 20 章 テストの声を聴く

```
暗黙のコンポーネントを抽出するときには、まず次のふたつの条件を探す。
クラス内で常に同時に使われている引数はないか、そして生存期間の同じ引数はないか。
条件を満たすものが見つかったら、より難しいタスクにとりかかる。
その概念をうまく説明する名前を考えるのだ。
```

（250p）

---

```
肥大したコンストラクタの三番目の症例は、引数の中に「依存ピア」ではないものが存在するというものだ。
「依存ピア」とは、「オブジェクトピアのステレオタイプ」（56ページ）で定義したステレオタイプのひとつだ。
そこでも書いたように、私たちは「依存」だけをコンストラクタで渡すように主張している。
「通知ピア」や「調整ピア」については、デフォルトを設定しておいて後から変更できるようにしておけばよい。
```

（252p）

---

```
意図を明確にするためには、スタブとエクスペクテーションやアサーションをきちんと区別するとよい。
スタブは実際の挙動をシミュレートしてテストの実行を支援するためのもの、そしてエクスペクテーションやアサーションはあるオブジェクトが隣接オブジェクトとどのようなやり取りをするのかを確かめるためのものだ。
```

（254p）

---

```
これまでに見てきたきな臭いテストの中には、たとえば「裏技」を使わないとモックを作成できない場合のように、コンポーネント間で知識が漏れ出しているせいでそうなっているものがある。
```

（256p）

---

```
「命じよ、訊ねるな」の方針を常に適用することを心がけると、値をスタックに積むのではなく、振る舞いを（コールバック形式で）システムに渡すようなコーディングスタイルにつながる。
```

（256p）

---

```
私が最近参加していたプロジェクトではjMockをヘビーに使い込んでいた。
振り返ってみると、そこで私が目にしたのはこのようなものだった。

1. ユニットテストが解読不能（何をやっているのかがわからない）になることがある。
2. テストクラスのコードが500行にも達することがある。さらに、そのクラスは別の抽象クラスを継承したものだったが、抽象クラス側のコードも500行に達している。
3. リファクタリングすると、テストコードに大量の変更が発生することがある。

ユニットテストが1000行にもなるなんて、あり得ないことだ！
```

（257p）

### 第 21 章 テストの可読性

```
TDDを続けていくためには、テストが単にコードの振る舞いを検証するだけでは不十分だ。
それだけではなく、テストで振る舞いを明確に表現しておかなければならない。
つまり、テストが読みやすくなければならないのだ。
```

（259p）

---

```
テストコードは、プロダクションコードが何をするのかを説明するものでなければならない。
```

（259p）

---

```
テストコードは依存関係の末端にあるので、テスト対象コードの意図を表現する方が、他のオブジェクトの網の目に組み込むことよりも重要となる。
```

（259p）

---

```
私たちがテストをきれいにしたり新たにテストを書いたりするときに、可読性を損なう問題として気をつけているのは以下の点だ。
・テスト名が、ここのテストケースのポイントや他のテストケースとの違いについてきちんと説明できていない。
・ひとつのテストケースが複数のフィーチャを実行しているように見える。
・さまざまな仕組みでテストしているため、ざっと眺めただけではテストの意図をつかみにくい。
・テストのセットアップや例外処理のためのコードが大量にあり、本質的なロジックが埋もれてしまっている。
・テストの中でリテラル値（「マジックナンバー」）が使われており、その値の何が重要（仮に重要であるとして）なのかがはっきりしない。
```

（260p）

- アンチパターン一覧

---

```
このような命名は、単に対象のクラスを見ればわかる情報を重複させているにすぎない。
「同じことを繰り返すな（Don't Repeat Yourself）」原則に反しているのだ。
```

（261p）

---

```
私たちは、クリス・スチーブンソンが考案したTestDoxの規約を使っている。
この規約では、テスト対象のクラスを暗黙の主語として、テスト名を一つの文として読めるようにする。
```

（261p）

---

```
この規約のポイントは、開発者にそのオブジェクトが「何者なのか」ではなく「何をするのか」という観点で考えさせるようにするということだ。
```

(261p）

- この `「何をするのか」` というのが振る舞いのことなのだろう

---

```
TDDを実践している人たちの中には、ひとつのテストに含めるエクスペクテーションやアサーションはひとつだけにするべきだと言う人もいる。
これは、TDDを学ぶときの練習用ルールとしては有用で、開発者の考え得ることをすべてアサートしてしまうことを避けられる。
しかし、実践的ではない。
ひとつのテストではひとつの凝集したフィーチャをテストするルールにした方がよい。
この場合、アサーションの数が少し増えても構わない。
ひとつのテストで異なるフィーチャのアサーションを行っているように見えたら、そのテストは分割したほうがよいだろう。
```

（264p）

- `考え得ることをすべてアサートしてしまう` というのはやりたくなりがちなことである

---

```
実装の詳細がテストメソッドに含まれれば含まれるほど、コードを読むときに何が重要なのかを読み取りにくくなる。
```

（264p）

---

```
テストの構造をこのように切り出す際に唯一気をつける点は、本章の冒頭に書いたとおり、テストをあまり抽象化しすぎないことだ。
さもないと、そのテストが何をしているのかを読み取れなくなってしまう。
私たちがもっとも重視しているのは、テストできちんと対象コードの動きを説明することだ。
```

## 考えたこと

- 戻り値の無いメソッドをテストすべきか・どうテストするのが適切か疑問だった
  - オブジェクト同士がメッセージを送り合うという点に着目すると、他のオブジェクトにメッセージを送ることがそのメソッドの責務になる
    - これをテストするのが適切ではないかという仮説を抱いた
