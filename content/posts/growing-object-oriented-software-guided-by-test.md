---
title: "Growing Object Oriented Software Guided by Test"
date: 2020-07-31T20:13:47+09:00
draft: true
tags:
  - テスト駆動開発
---

# 本のメタデータ

## タイトル

実践テスト駆動開発

## amazon URL

https://www.amazon.co.jp/dp/product/4798124583/ref=nosim?tag=inunekotokage-22

## 著者

- Steve Freeman (著)
- Nat Pryce (著)
- 和智 右桂 (翻訳)
- 高木 正弘 (翻訳)

## 気になった箇所

### 第 1 章

```
システムを確実に成長させ、常に起きる予期せぬ変化に対処していくためには、技術的な基盤がふたつ必要だということがわかった。まずは、常にテストを実施してリグレッションエラーを検出する必要がある。（中略）次に必要なのは、コードをできる限りシンプルにしておくことだ。
```

（5p）

---

```
エンドツーエンドテストを実行することで、システムの外側の質がわかり、
エンドツーエンドテストを書くことでドメインについて私たち（チーム全体）がどれほど理解できているかについての知見が得られる。
しかし、エンドツーエンドテストではどのくらいコードがきちんと書かれているかはわからない。

一方、ユニットテストを書くことで、コードの質についてのフィードバックを数多く得ることができる。
さらに、ユニットテストを実行することで、どのクラスも壊れていないことがわかる。

しかし、繰り返しになるが、ユニットテストでは、システムが全体として機能することへの自信を十分には与えてはくれないのだ。
インテグレーションテストは、図1-3に示すように両者の間のどこかに位置づけられる。
```

（11p）

### 第 2 章

```
私たちから見れば、ドメインモデルはこうしたコミュニケーションパターンの中に存在する。
なぜならコミュニケーションパターンこそが、オブジェクト間で生じ得る関係性という領域に意味を与えるからだ。
```

（17p）

---

```
クラス階層で表現できるのは、うまくいったとしてもせいぜいアプリケーションのある一側面だけにすぎない。
これは単に実装の詳細をオブジェクト間で共有する仕組みを提供しているだけだ。
```

（18p）

---

```
複数のオブジェクトが互いにメッセージを送りあっている。
そうしたメッセージはどんな内容だろう？
私達の経験によれば、呼び出し元のオブジェクトは、呼び出し先のオブジェクトが演じているロールの観点から、何をしてほしいかを記述しなければならない。
そして、どうやってそのようにするかは呼び出されたオブジェクトに任せるのだ。
これは一般的に「命じよ、訊ねるな（Tell, Don't Ask）」というフレーズで知られるスタイルであり、もっと形式ばった言い回しではデメテルの掟と呼ばれる。
```

（18p）

---

```
前傾のサンプルでいえば、短い方のコードは何のためかを明確に記述しており、列車事故のコードとは異なり、単にどのように実装しているかを記述するだけではなくなっているのだ。
```

（20p）

### 第 5 章

```
まずはテストを失敗させて、診断メッセージを確認するのだ。
もしテストが予期せぬやり方で失敗した場合には、何かを誤解したか、コードが不十分だったかのどちらかだ。
その場合まずはそれを修正する。「正しく」失敗したら、診断メッセージを見て原因がわかることを確認する。
失敗理由の説明がわかりにくければ、数週間後にコードが壊れたときに誰かが（もしかしたら自分が）苦労することになる。
```

（46p）

---

```
エラーメッセージを確認せよと主張するのには、いくつかの理由がある。
第一に、取り組んでいるコードに対する私達の想定を確認できる。その想定が間違っていることも時々あるのだ。
第二に、もうすこし細かい話として、自分たちの意図を表現することを強調すること（情熱を傾けること、と言ってもよいかもしれない）は、
信頼でき保守しやすいシステムを開発する上で欠かせないことだと分かっている。
こうしたシステムには、テストや失敗メッセージも含まれるのだ。
手間を掛けて役に立つ診断メッセージが出力されるようにすることで、そのテストが何をすべきか、さらにそこから、そのコードが何をすべきかが明らかになる。
```

（47p）

---

```
新しいドメインモデルのユニットテストから始め、それをアプリケーション内の残りの部分に紐付けるという発想は魅力的だ。
そのほうが最初は簡単に思える。ドメインモデルを何かに組み入れる必要がなければ、非常に早く作業が進むように感じられる。
しかし、このやり方ではあとになって統合の問題に苦しめられることになるだろう。
あるいは、不要であったり、間違っていたりする機能を構築してしまって、時間を無駄にすることになるかもしれない。
作業時に適切なフィードバックを受け取ることができないからだ。
```

（47p）

---

```
これに関するよくある過ちが、メソッドをテストするという考え方だ。
testBidAccepted()という名前のついたテストは、何をしているかはわかるが、何のためにテストしているかが分からない。
むしろ、テスト対象のオブジェクトが提供すべきフィーチャに集中した方がよい。
それぞれのフィーチャでオブジェクトは複数の隣接オブジェクトとコラボレーションする必要があり、メソッドも複数呼び出されるからだ。
知りたいのは、目的を達成するためにクラスをどう使えばよいかということだ。
コード内のすべてのパスを実行する方法ではない。
```

（48p）

---

```
テストをするのが難しいフィーチャを見つけたときには、それをどうテストするかを自問するだけでなく、なぜテストするのが難しいのかも問わなければならないのだ。
```

（49p）

---

```
私たちの経験によれば、コードをテストするのが難しい場合、設計を改善する必要のあることがほとんどだ。
```

（49p）

---

```
図5-3が示すように次の失敗するテストを書くのが難しければ、プロダクションコードの設計を見直し、先に進む前にリファクタリングをするのである。
これは、私たちの格言である「予期せぬ変更を予期せよ」によって、開発がどう導かれるかを示す例である。
```

（49p）

---

```
モックオブジェクトを使って外部の依存関係を断ち切るようなユニットテストは、どのくらいやるべきだろう？
そして、インテグレーションテストはどのくらいやるべきだろう？
こうした問題に対して答えがひとつだけとは思わない。
チームや環境といったコンテキストに大きく依存しているからだ。
```

（50p）

---

```
TDDの持つテストの側面（これはTDDの大部分を占める）が与えてくれる最高のものは、コードを壊さずに変更できるという自信だ。
恐れると先に進めなくなる。
このときのコツは、自信を確実に裏付けることである。
```

（50p）

---

```
そして私たちは、TDDが自分たちにとって機能しているか、あらゆる欠点を見定めているか、テスト戦略に適しているか、といったことを定期的にふりかえるのだ。
```

（50p）

### 第 19 章

```
私たちにはヘルパーメソッドを書いて、少量のコードをまとめるという習慣がある。（中略）ヘルパーメソッドを作ることで、構造に意味のある名前が与えられる。
そうでもしなければ、構造の意味は明らかにならないのだ。
```

（235p）

### 第 20 章

```
これまでに見てきたきな臭いテストの中には、たとえば「裏技」を使わないとモックを作成できない場合のように、コンポーネント間で知識が漏れ出しているせいでそうなっているものがある。
```

（256p）

---

```
「命じよ、訊ねるな」の方針を常に適用することを心がけると、値をスタックに積むのではなく、振る舞いを（コールバック形式で）システムに渡すようなコーディングスタイルにつながる。
```

（256p）

---

```
私が最近参加していたプロジェクトではjMockをヘビーに使い込んでいた。
振り返ってみると、そこで私が目にしたのはこのようなものだった。

1. ユニットテストが解読不能（何をやっているのかがわからない）になることがある。
2. テストクラスのコードが500行にも達することがある。さらに、そのクラスは別の抽象クラスを継承したものだったが、抽象クラス側のコードも500行に達している。
3. リファクタリングすると、テストコードに大量の変更が発生することがある。

ユニットテストが1000行にもなるなんて、あり得ないことだ！
```

（257p）

### 第 21 章

```
TDDを続けていくためには、テストが単にコードの振る舞いを検証するだけでは不十分だ。
それだけではなく、テストで振る舞いを明確に表現しておかなければならない。
つまり、テストが読みやすくなければならないのだ。
```

（259p）

---

```
テストコードは、プロダクションコードが何をするのかを説明するものでなければならない。
```

（259p）

---

```
テストコードは依存関係の末端にあるので、テスト対象コードの意図を表現する方が、他のオブジェクトの網の目に組み込むことよりも重要となる。
```

（259p）

---

```
私たちがテストをきれいにしたり新たにテストを書いたりするときに、可読性を損なう問題として気をつけているのは以下の点だ。
・テスト名が、ここのテストケースのポイントや他のテストケースとの違いについてきちんと説明できていない。
・ひとつのテストケースが複数のフィーチャを実行しているように見える。
・さまざまな仕組みでテストしているため、ざっと眺めただけではテストの意図をつかみにくい。
・テストのセットアップや例外処理のためのコードが大量にあり、本質的なロジックが埋もれてしまっている。
・テストの中でリテラル値（「マジックナンバー」）が使われており、その値の何が重要（仮に重要であるとして）なのかがはっきりしない。
```

（260p）

- アンチパターン一覧

---

```
このような命名は、単に対象のクラスを見ればわかる情報を重複させているにすぎない。
「同じことを繰り返すな（Don't Repeat Yourself）」原則に反しているのだ。
```

（261p）

---

```
私たちは、クリス・スチーブンソンが考案したTestDoxの規約を使っている。
この規約では、テスト対象のクラスを暗黙の主語として、テスト名を一つの文として読めるようにする。
```

（261p）

---

```
この規約のポイントは、開発者にそのオブジェクトが「何者なのか」ではなく「何をするのか」という観点で考えさせるようにするということだ。
```

(261p）

- この `「何をするのか」` というのが振る舞いのことなのだろう

---

```
TDDを実践している人たちの中には、ひとつのテストに含めるエクスペクテーションやアサーションはひとつだけにするべきだと言う人もいる。
これは、TDDを学ぶときの練習用ルールとしては有用で、開発者の考え得ることをすべてアサートしてしまうことを避けられる。
しかし、実践的ではない。
ひとつのテストではひとつの凝集したフィーチャをテストするルールにした方がよい。
この場合、アサーションの数が少し増えても構わない。
ひとつのテストで異なるフィーチャのアサーションを行っているように見えたら、そのテストは分割したほうがよいだろう。
```

（264p）

- `考え得ることをすべてアサートしてしまう` というのはやりたくなりがちなことである

---

```
実装の詳細がテストメソッドに含まれれば含まれるほど、コードを読むときに何が重要なのかを読み取りにくくなる。
```

（264p）

---

```
テストの構造をこのように切り出す際に唯一気をつける点は、本章の冒頭に書いたとおり、テストをあまり抽象化しすぎないことだ。
さもないと、そのテストが何をしているのかを読み取れなくなってしまう。
私たちがもっとも重視しているのは、テストできちんと対象コードの動きを説明することだ。
```
